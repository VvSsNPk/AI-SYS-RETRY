{"$message_type":"diagnostic","message":"expected identifier, found keyword `move`","code":null,"level":"error","spans":[{"file_name":"src/map.rs","byte_start":1553,"byte_end":1557,"line_start":58,"line_end":58,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"                   let move = first + count;","highlight_start":24,"highlight_end":28}],"label":"expected identifier, found keyword","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"escape `move` to use it as an identifier","code":null,"level":"help","spans":[{"file_name":"src/map.rs","byte_start":1553,"byte_end":1553,"line_start":58,"line_end":58,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"                   let move = first + count;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":"r#","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected identifier, found keyword `move`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/map.rs:58:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                   let move = first + count;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected identifier, found keyword\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: escape `move` to use it as an identifier\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   let \u001b[0m\u001b[0m\u001b[38;5;10mr#\u001b[0m\u001b[0mmove = first + count;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[38;5;10m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected one of `async`, `|`, or `||`, found `,`","code":null,"level":"error","spans":[{"file_name":"src/map.rs","byte_start":1617,"byte_end":1618,"line_start":59,"line_end":59,"column_start":43,"column_end":44,"is_primary":true,"text":[{"text":"                   &mut self.start = (move,second);","highlight_start":43,"highlight_end":44}],"label":"expected one of `async`, `|`, or `||`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `async`, `|`, or `||`, found `,`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/map.rs:59:43\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                   &mut self.start = (move,second);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `async`, `|`, or `||`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `usize: Neg` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/map.rs","byte_start":1452,"byte_end":1454,"line_start":55,"line_end":55,"column_start":28,"column_end":30,"is_primary":true,"text":[{"text":"                   count = -1;","highlight_start":28,"highlight_end":30}],"label":"the trait `Neg` is not implemented for `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Neg`:\n  isize\n  i8\n  i16\n  i32\n  i64\n  i128\n  f32\n  f64\nand 8 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `usize: Neg` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/map.rs:55:28\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m55\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                   count = -1;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Neg` is not implemented for `usize`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Neg`:\u001b[0m\n\u001b[0m             isize\u001b[0m\n\u001b[0m             i8\u001b[0m\n\u001b[0m             i16\u001b[0m\n\u001b[0m             i32\u001b[0m\n\u001b[0m             i64\u001b[0m\n\u001b[0m             i128\u001b[0m\n\u001b[0m             f32\u001b[0m\n\u001b[0m             f64\u001b[0m\n\u001b[0m           and 8 others\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"invalid left-hand side of assignment","code":{"code":"E0070","explanation":"An assignment operator was used on a non-place expression.\n\nErroneous code examples:\n\n```compile_fail,E0070\nstruct SomeStruct {\n    x: i32,\n    y: i32,\n}\n\nconst SOME_CONST: i32 = 12;\n\nfn some_other_func() {}\n\nfn some_function() {\n    SOME_CONST = 14; // error: a constant value cannot be changed!\n    1 = 3; // error: 1 isn't a valid place!\n    some_other_func() = 4; // error: we cannot assign value to a function!\n    SomeStruct::x = 12; // error: SomeStruct a structure name but it is used\n                        //        like a variable!\n}\n```\n\nThe left-hand side of an assignment operator must be a place expression. A\nplace expression represents a memory location and can be a variable (with\noptional namespacing), a dereference, an indexing expression or a field\nreference.\n\nMore details can be found in the [Expressions] section of the Reference.\n\n[Expressions]: https://doc.rust-lang.org/reference/expressions.html#places-rvalues-and-temporaries\n\nAnd now let's give working examples:\n\n```\nstruct SomeStruct {\n    x: i32,\n    y: i32,\n}\nlet mut s = SomeStruct { x: 0, y: 0 };\n\ns.x = 3; // that's good !\n\n// ...\n\nfn some_func(x: &mut i32) {\n    *x = 12; // that's good !\n}\n```\n"},"level":"error","spans":[{"file_name":"src/map.rs","byte_start":1594,"byte_end":1609,"line_start":59,"line_end":59,"column_start":20,"column_end":35,"is_primary":false,"text":[{"text":"                   &mut self.start = (move,second);","highlight_start":20,"highlight_end":35}],"label":"cannot assign to this expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/map.rs","byte_start":1610,"byte_end":1611,"line_start":59,"line_end":59,"column_start":36,"column_end":37,"is_primary":true,"text":[{"text":"                   &mut self.start = (move,second);","highlight_start":36,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider dereferencing here to assign to the mutably borrowed value","code":null,"level":"help","spans":[{"file_name":"src/map.rs","byte_start":1594,"byte_end":1594,"line_start":59,"line_end":59,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"                   &mut self.start = (move,second);","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":"*","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0070]\u001b[0m\u001b[0m\u001b[1m: invalid left-hand side of assignment\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/map.rs:59:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                   &mut self.start = (move,second);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mcannot assign to this expression\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider dereferencing here to assign to the mutably borrowed value\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[38;5;10m*\u001b[0m\u001b[0m&mut self.start = (move,second);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the type `[Vec<Square>]` cannot be indexed by `&usize`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/map.rs","byte_start":1656,"byte_end":1661,"line_start":60,"line_end":60,"column_start":30,"column_end":35,"is_primary":true,"text":[{"text":"                   &self.map[first][second];","highlight_start":30,"highlight_end":35}],"label":"slice indices are of type `usize` or ranges of `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `SliceIndex<[Vec<Square>]>` is not implemented for `&usize`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `SliceIndex<[Vec<Square>]>` is implemented for `usize`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `usize`, found `&usize`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Vec<Vec<Square>>` to implement `Index<&usize>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"dereference this index","code":null,"level":"help","spans":[{"file_name":"src/map.rs","byte_start":1656,"byte_end":1656,"line_start":60,"line_end":60,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"                   &self.map[first][second];","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":"*","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the type `[Vec<Square>]` cannot be indexed by `&usize`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/map.rs:60:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                   &self.map[first][second];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mslice indices are of type `usize` or ranges of `usize`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `SliceIndex<[Vec<Square>]>` is not implemented for `&usize`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `SliceIndex<[Vec<Square>]>` \u001b[0m\u001b[0m\u001b[1m\u001b[35mis\u001b[0m\u001b[0m implemented for `\u001b[0m\u001b[0m\u001b[1m\u001b[35musize\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for that trait implementation, expected `usize`, found `&usize`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `Vec<Vec<Square>>` to implement `Index<&usize>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: dereference this index\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   &self.map[\u001b[0m\u001b[0m\u001b[38;5;10m*\u001b[0m\u001b[0mfirst][second];\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 5 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 5 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0070, E0277.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0070, E0277.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0070`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0070`.\u001b[0m\n"}
